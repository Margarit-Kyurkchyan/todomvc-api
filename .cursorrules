# Ecor Rouge Sample Project - TodoMVC

## Version
v1.2.0

## Overview
We use our internally developed framework, rococo, to build most of our software, so this project was designed to show that you understand the concepts and can use the code effectively.

Your task is to implement TodoMVC (https://todomvc.com/) with a backend to store data. You should use Postgres for data storage.

## Requirements

The application must use both the Vue3 sample project (https://github.com/EcorRouge/rococo-sample-vue3) and the backend sample project (https://github.com/EcorRouge/rococo-sample-backend). Please start by forking each one; your code can be in a public repository.

### Functionality
The application must allow the user to:
1. Sign up.
2. Reset their password via the password reset email.
3. Log in.
4. Log out.
5. Set/edit their name.
6. See a list of their tasks.
7. Add tasks.
8. Edit tasks.
9. Mark tasks as complete.
10. Filter the list to show incomplete tasks, completed tasks, or both.
11. Delete tasks.

### Technology
1. The frontend must be written in JavaScript.
2. The backend must be written in Python, use rococo, and run in Docker containers.
3. All environment-specific variables that are not secrets must be in local.env.
4. Any secret values (passwords, API keys, etc.) need to have placeholders with self-explanatory names in .env.secrets.example, and there must be no actual secret values committed to GitHub.
5. The run.sh script should launch the entire backend.
6. Running quasar dev should launch the frontend, connected to the backend.
7. Mailjet will be used for sending emails - credentials and template IDs are at the end of this document. You must only test with email addresses that you control - no mailinator, no "test.com", or anything other than an actual email address where you receive email.

## Judgement Criteria
Your application will be judged on the following criteria:
1. Providing the functionality listed in the requirements.
2. Ease of launching the system.
3. How it looks, works, and feels.
4. How long it took to implement.
5. Questions that were asked.
6. Code structure.
7. How the new code feels compared to our existing code. (i.e. does it look strange or feel like us?)
8. Anything "extra" that we didn't ask for.

## Process
1. Create public GitHub repositories in your own GitHub account.
2. Use the rococo-sample repos as a starting point.
3. Implement the functionality.
4. Make sure that everything in your project is named based on the application name you're given (i.e. we shouldn't see Rococo Sample Application anywhere).
5. Send your GitHub repo links to Jay using Upwork Messenger.
   - NOTE: Please do not open a PR to the rococo-sample repos - we are not looking to update the sample code, we provide it as a starting point for your application only.

## Overall Goal
Please keep in mind that this sample project is designed to show us what it is like to work with you. You must use the Upwork time tracker the entire time you are working on the task. We expect to pay for your time, and the time tracker is the only way we will be able to see how you work. Do not do work without the time tracker and try to explain it away by saying that you didn't want to charge us for reading, thinking, researching, etc. - we absolutely expect to pay for your time and need to see how you work.

Asking questions is fine, but we expect questions that require our input that couldn't be answered with this document, Google, or ChatGPT.

We expect what you deliver to work the first time we run it. It is very, very hard to overcome delivering something that doesn't launch and trying to explain it away. This is probably the easiest task you'll ever be assigned here and is designed to really let you show what you can do.

This isn't a trick project; it is as simple as it sounds, and we really hope that you'll be able to deliver something we like quickly and efficiently.

## Email Templates
Both templates have variables that you need to populate with the link to your verification or password reset URL. The variables are in the sample code. You should use sample_project@ecortest.com as the sender. Please only use email addresses that you control for testing. Entering random email addresses and causing hard bounces will reduce the deliverability of our domain.

- Verify Email: Template ID 6410451
- Reset Password: Template ID 6410454


## Coding Standards - What Is Bad Code

### Principles: Avoid Bad Code
Bad code is difficult to understand, change, fix, and expand. Bad code is different than incorrect code - incorrect code doesn't work correctly but can be easily fixed. Incorrect bad code is the worst because it doesn't work correctly, and it's hard to fix.

Code is bad for these reasons. **Always avoid these patterns:**

1. **Is implicit rather than explicit**
   - ❌ Bad: Nesting function calls instead of setting a variable
   - ✅ Good: Set intermediate variables with clear names before using them
   - Example: `const result = processData(transformData(rawData))` → `const transformed = transformData(rawData); const result = processData(transformed)`

2. **Contains incorrect assumptions, often implicit**
   - ❌ Bad: Assuming values exist without checking (leads to NoneType/null errors)
   - ✅ Good: Explicitly check for null/undefined/None before using values
   - Always validate inputs and handle edge cases explicitly

3. **Is terse instead of readable**
   - ❌ Bad: Implicit assignment, ternary operators, complex lambdas as function parameters
   - ✅ Good: Use explicit variable assignments, clear if/else statements, extract complex logic to named functions
   - Avoid: `const result = condition ? func1() : func2()` when the logic is complex
   - Prefer: Clear if/else blocks or extracted functions with descriptive names

4. **Makes it hard to set breakpoints and/or logging statements**
   - ❌ Bad: Complex one-liners that can't be easily debugged
   - ✅ Good: Break code into steps that can be individually inspected
   - Each logical step should be on its own line or in its own function
   - Make it easy to add `console.log()` or breakpoints between steps

5. **Does too much**
   - ❌ Bad: Long functions that do multiple things
   - ✅ Good: Functions should be short, clear, and focused on one thing
   - Functions should read like a logical narrative explaining what the system is doing
   - Sequence complex behavior by calling multiple focused functions

6. **Contains "layer leakage"**
   - ❌ Bad: Database code inside models, API logic in service layers, etc.
   - ✅ Good: Keep concerns separated - models handle data structure, services handle business logic, repositories handle data access
   - Each layer should have clear responsibilities

## Ecor Rouge Architecture Principles

### Repository Pattern

The repository is the **only** part of the system that connects to data stores (databases, caches, etc.). Follow these principles:

- **Single Factory**: There should be a single factory in every service and API that constructs the repository
- **Model Interface**: Repository interfaces consume and return domain models only - the application "talks" to the repository in terms of models
- **Encapsulation**: The application has no "knowledge" of how data is stored and retrieved - the repository encapsulates all data access functionality
- **No Direct Data Access**: Never access databases, caches, or external data stores outside of the repository layer

### CQRS (Command Query Responsibility Segregation)

- **Commands**: Data changes are processed by sending messages (commands) to be handled asynchronously
- **Queries**: Data retrieval queries access data stores directly
- **Repository Implementation**: All CQRS logic happens within the repository - application code doesn't "know" how things are stored or retrieved
- **Implicit Messaging**: When API calls `save()` on a model, a message is sent instead of directly saving - this is handled by the repository

### Layer Responsibilities

#### API Layer
- **Purpose**: Interface to the application, not the application itself
- **Responsibilities**: 
  - Expose system functionality via REST/GraphQL
  - Send messages via Repository (cannot consume messages)
  - Talk to Repository via models only
  - **DO NOT**: Contain business logic, send emails, charge cards, or perform actions directly
- **Example**: API sends a "password reset command" via Repository, but does NOT contain password reset logic

#### Services Layer
- **Purpose**: Process commands and react to events
- **Responsibilities**:
  - Contain application logic (NOT in API)
  - Process commands (e.g., "save", "send email")
  - Subscribe to commands or events
  - Send messages via Repository
- **Example**: Password reset service processes the command by creating a one-time code and sending a "send email" command

#### Repository Layer
- **Purpose**: Separate application functionality from data storage
- **Responsibilities**:
  - Handle all data access (queries, transactions)
  - Translate between models and native data format
  - Handle messaging (implicit and explicit)
  - Encapsulate all database and external service connections

#### Messaging
- **Purpose**: Send commands asynchronously
- **Pattern**: All messaging happens via Repository (either implicit or explicit)
- **Implicit**: API calling `save()` on a model sends a message automatically
- **Explicit**: Service using Repository to subscribe to events or commands

### The Three Cs

#### Coupling (Bad - Avoid)
- **Definition**: Things that can't be easily separated
- **Examples to Avoid**:
  - ❌ Putting "tablename" in a model (couples model to data storage)
  - ❌ Model "knows too much" about data storage
  - ❌ Wrong property placement (e.g., LastLoginTime on user table - user definition isn't changing)
- **Principle**: Keep code as decoupled as possible for flexibility and easier changes

#### Cohesion (Good - Strive For)
- **Definition**: How related things are - a good form of coupling
- **Examples**:
  - ✅ All "user" functionality in the same class
  - ❌ "utils" or "helpers" files with unrelated functions (becomes a junk drawer)
  - ✅ Better: "formatting_helpers" or "time_utils" that indicate related functionality

#### Complexity
- **In Functions (Bad)**: 
  - Avoid nested if/else statements
  - Each if/else doubles the number of tests required
  - Nested if/else makes code hard to understand and test
  - Example: 3 levels of nesting = 8 tests needed for one function
- **In Systems (Good)**:
  - Complex system = large collection of small parts
  - Complicated system = smaller collection of bigger parts
  - We want complex systems (many small, focused parts)
  - Allows focusing on small parts without remembering the entire system

### Eventual Consistency

- **Definition**: System is "eventually consistent" - there is a period where one user's view may be inconsistent with another user's view
- **Acceptable**: Perfectly fine for the vast majority of use cases
- **Not Acceptable**: "Accounting" functionality where system state must be consistent for all users
- **Note**: Systems requiring accounting-level consistency typically have other functionality that can use eventual consistency - identify and isolate such functionality

### Architecture Checklist

Before writing or reviewing code, ensure:
- [ ] Repository is the only layer accessing data stores
- [ ] API contains no business logic (only interface)
- [ ] Services contain application logic (not in API)
- [ ] All messaging happens via Repository
- [ ] Models have no knowledge of data storage
- [ ] No coupling between models and data storage
- [ ] Related functionality is grouped together (cohesive)
- [ ] Functions avoid nested if/else (complexity in functions is bad)
- [ ] System is built as many small parts (complexity in systems is good)

### Refactoring Guidelines

When refactoring existing code, follow these principles:

1. **Refactoring = Change structure, NOT functionality**
   - The functionality must remain exactly the same
   - Tests are required before refactoring

2. **Test Requirements**
   - One test for the happy path
   - One test for each error that is handled
   - Tests must be fast and easy to run
   - Tests must stay green (passing) throughout the refactoring process

3. **Refactor Top-Down**
   - Start at the highest level of the call chain (e.g., API layer)
   - Clean upper layers first, work down to lower layers
   - Work function-by-function
   - Run tests after each change - they must remain green

4. **Refactoring Steps**
   - Step 1: Put tests at the highest level of the call chain
   - Step 2: Change code at the highest level to be good (extract functions, improve readability)
   - Step 3: Go through entire call chain step-by-step, cleaning each function
   - Run tests after each change - they must remain green

### Backend Code Refactoring Process

When refactoring backend code to improve structure and maintainability, follow this specific process:

#### Model Refactoring
1. **Move model code to its own file**
   - Move the code for the specific model you're working with to its own file in the `/models` folder (e.g., `common/models/person.py`)
   - Each model should be in a separate file named after the model (use lowercase with underscores)

2. **Update model imports**
   - Change the `models/__init__.py` imports to import from the new file
   - Ensure all existing imports continue to work

3. **Verify and commit**
   - Run the tests to ensure that everything still works
   - Commit and push the change so that you can now work on the model without merge conflicts

#### Repository Refactoring
4. **Move repository code to its own file**
   - Move the code for the specific repository you're working with to its own file in the `/repositories` folder (e.g., `common/repositories/person.py`)
   - Each repository should be in a separate file named after the repository (use lowercase with underscores)

5. **Update repository imports**
   - Change the `repositories/__init__.py` imports to import from the new file
   - Ensure all existing imports continue to work

6. **Verify and commit**
   - Run the tests to ensure that everything still works
   - Commit and push the change so that you can now work on the repository without merge conflicts

#### Separation of Concerns
7. **Move database code from model to repository**
   - All database operations (queries, transactions, etc.) must be in the repository layer
   - Models should only contain data structure definitions and model-specific logic
   - No database adapters or connection code should be in models

8. **Move external service code to repository**
   - Move Pusher, messaging services (RabbitMQ), and any other external service code to the repository
   - The model should be clean and only deal with model data and model logic
   - External service integrations belong in the repository or service layer, not in models

9. **Refactor application functions**
   - Refactor the rest of the application functions to follow good code practices
   - Ensure proper separation of concerns across all layers
   - Apply the coding standards and principles outlined in this document

#### Key Principles
- **One model per file**: Each model class should have its own file
- **One repository per file**: Each repository class should have its own file
- **Clean models**: Models contain only data structure and model logic, no database or external service code
- **Repository handles data access**: All database operations and external service integrations belong in repositories
- **Test after each step**: Always run tests and commit after each refactoring step to maintain a stable codebase

### Code Quality Checklist

Before writing or reviewing code, ensure:
- [ ] Code is explicit, not implicit
- [ ] All assumptions are validated (no null/undefined errors)
- [ ] Code is readable, not terse
- [ ] Breakpoints and logging can be easily added
- [ ] Functions do one thing and are focused
- [ ] No layer leakage (concerns are properly separated)
- [ ] Code reads like a logical narrative